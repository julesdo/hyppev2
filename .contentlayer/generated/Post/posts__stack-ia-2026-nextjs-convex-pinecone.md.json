{
  "title": "Ma Stack IA 2026 : L'Architecture qui Délivre",
  "date": "2026-01-28T00:00:00.000Z",
  "image": "/ma-stack.png",
  "excerpt": "Next.js 16, Convex, Pinecone, tRPC... Voici la stack que j'utilise pour shipper des apps IA production-ready en un temps record.\r",
  "body": {
    "raw": "\r\nAprès des dizaines de projets IA, j'ai convergé vers une stack qui coche toutes les cases : **DX de rêve**, **type-safety absolue**, et **scalabilité native**. Pas de compromis.\r\n\r\nEn tant que Product Engineer, je ne cherche pas la hype. Je cherche ce qui **shippe vite** et **tient la charge**. Voici mon arsenal 2026.\r\n\r\n## Le Frontend : Next.js 16 + TypeScript\r\n\r\n**Next.js 16** n'est plus un framework, c'est un **runtime**. Avec le Server Components par défaut, le Turbopack stable, et les **Partial Prerendering**, on atteint des performances qu'on croyait réservées aux apps natives.\r\n\r\n- **Turbopack** : Build 10x plus rapide que Webpack. Le HMR est instantané.\r\n- **Server Actions** : Plus besoin d'API routes pour les mutations simples.\r\n- **Edge Runtime** : Du code qui s'exécute à 50ms de l'utilisateur, partout dans le monde.\r\n\r\nLe tout avec **TypeScript strict**. Pas de `any`, pas de surprise en prod.\r\n\r\n## La Communication : tRPC + NestJS\r\n\r\nExit les schémas REST ou GraphQL à maintenir. **tRPC** donne une **API type-safe de bout en bout** sans génération de code.\r\n\r\n```typescript\r\n// Le type est inféré automatiquement côté client\r\nconst user = await trpc.user.getById.query({ id: \"123\" });\r\n// user est typé User, pas unknown\r\n```\r\n\r\nPour les services complexes, **NestJS** structure le backend avec une architecture modulaire :\r\n\r\n- **Domain-Driven Design** natif avec les modules\r\n- **Dependency Injection** propre\r\n- Écosystème riche : guards, interceptors, pipes\r\n\r\n## Le Temps Réel : Convex.dev\r\n\r\n**Convex** a changé ma façon de penser le backend. C'est une **base de données réactive** avec des fonctions serverless intégrées.\r\n\r\n```mermaid\r\nflowchart TB\r\n    subgraph Client\r\n        A[Next.js App]\r\n    end\r\n    subgraph Convex\r\n        B[Realtime Database]\r\n        C[Server Functions]\r\n        D[Scheduled Jobs]\r\n    end\r\n    subgraph AI Layer\r\n        E[Pinecone]\r\n        F[Qdrant]\r\n        G[OpenAI]\r\n    end\r\n    \r\n    A <-->|WebSocket| B\r\n    A --> C\r\n    C --> B\r\n    C --> E\r\n    C --> F\r\n    C --> G\r\n    D --> C\r\n    \r\n    style A fill:#FC5757,color:#fff\r\n    style B fill:#FC5757,color:#fff\r\n    style C fill:#1a1d24,stroke:#FC5757\r\n```\r\n\r\n**Pourquoi Convex ?**\r\n\r\n- **Réactivité native** : Les queries se mettent à jour automatiquement. Pas de polling, pas de cache invalidation manuelle.\r\n- **Transactions ACID** : Contrairement à Firebase, vos données sont cohérentes.\r\n- **TypeScript natif** : Le schéma de base génère les types automatiquement.\r\n\r\n## L'Intelligence : Pinecone + Qdrant\r\n\r\nPour les projets IA, j'utilise **deux bases vectorielles** selon le use case :\r\n\r\n| Critère | Pinecone | Qdrant |\r\n|---------|----------|--------|\r\n| **Scaling** | Serverless, 0 config | Self-hosted ou cloud |\r\n| **Coût** | Pay-per-query | Prévisible |\r\n| **Latence** | ~50ms | ~20ms (self-hosted) |\r\n| **Filtres** | Metadata basique | Filtres complexes |\r\n\r\n**Pinecone** pour le MVP et le scaling automatique. **Qdrant** quand on veut du contrôle total et des filtres avancés.\r\n\r\nLes deux s'intègrent parfaitement avec un pipeline RAG :\r\n\r\n$$similarity(q, d) = \\frac{q \\cdot d}{\\|q\\| \\times \\|d\\|}$$\r\n\r\n## Le Déploiement : Vercel Edge + PWA\r\n\r\n**Vercel** n'est plus optionnel pour Next.js. Les **Edge Functions** permettent :\r\n\r\n- **Middleware global** : Auth, A/B testing, geolocation en <1ms\r\n- **ISR On-Demand** : Revalidation ciblée sans rebuild complet\r\n- **Analytics intégrés** : Web Vitals en temps réel\r\n\r\nPour l'expérience mobile, je transforme chaque app en **PWA** :\r\n\r\n- **Service Workers** : Offline-first, sync en background\r\n- **Push Notifications** : Engagement sans app native\r\n- **Installation** : Icône sur l'écran d'accueil\r\n\r\n## La Stack Complète\r\n\r\nVoici comment tous ces éléments s'articulent :\r\n\r\n```mermaid\r\nflowchart LR\r\n    subgraph Frontend\r\n        A[Next.js 16]\r\n        B[PWA Layer]\r\n    end\r\n    \r\n    subgraph API\r\n        C[tRPC Router]\r\n        D[NestJS Services]\r\n    end\r\n    \r\n    subgraph Data\r\n        E[Convex DB]\r\n        F[Pinecone/Qdrant]\r\n    end\r\n    \r\n    subgraph Infra\r\n        G[Vercel Edge]\r\n        H[OpenAI/Anthropic]\r\n    end\r\n    \r\n    A --> C\r\n    B --> A\r\n    C --> D\r\n    C --> E\r\n    D --> F\r\n    D --> H\r\n    G --> A\r\n    \r\n    style A fill:#FC5757,color:#fff\r\n    style E fill:#FC5757,color:#fff\r\n    style G fill:#1a1d24,stroke:#FC5757\r\n```\r\n\r\n## Pourquoi Cette Stack Gagne\r\n\r\n- **Time-to-Market** : Du prototype au prod en 2 semaines, pas 2 mois.\r\n- **Type-Safety** : Zéro bug de typage entre frontend et backend.\r\n- **Scalabilité** : De 0 à 100k users sans rearchitecturer.\r\n- **Coût** : Serverless = on paie ce qu'on consomme.\r\n- **DX** : Hot reload instantané, erreurs explicites, debugging facile.\r\n\r\n---\r\n\r\n**Leçon apprise** : La meilleure stack n'est pas celle qui a le plus de features. C'est celle qui vous fait **shipper plus vite** tout en dormant tranquille. En 2026, cette combinaison Next.js + Convex + Vector DB est mon arme secrète.\r\n",
    "html": "<p>Après des dizaines de projets IA, j'ai convergé vers une stack qui coche toutes les cases : <strong>DX de rêve</strong>, <strong>type-safety absolue</strong>, et <strong>scalabilité native</strong>. Pas de compromis.</p>\n<p>En tant que Product Engineer, je ne cherche pas la hype. Je cherche ce qui <strong>shippe vite</strong> et <strong>tient la charge</strong>. Voici mon arsenal 2026.</p>\n<h2>Le Frontend : Next.js 16 + TypeScript</h2>\n<p><strong>Next.js 16</strong> n'est plus un framework, c'est un <strong>runtime</strong>. Avec le Server Components par défaut, le Turbopack stable, et les <strong>Partial Prerendering</strong>, on atteint des performances qu'on croyait réservées aux apps natives.</p>\n<ul>\n<li><strong>Turbopack</strong> : Build 10x plus rapide que Webpack. Le HMR est instantané.</li>\n<li><strong>Server Actions</strong> : Plus besoin d'API routes pour les mutations simples.</li>\n<li><strong>Edge Runtime</strong> : Du code qui s'exécute à 50ms de l'utilisateur, partout dans le monde.</li>\n</ul>\n<p>Le tout avec <strong>TypeScript strict</strong>. Pas de <code>any</code>, pas de surprise en prod.</p>\n<h2>La Communication : tRPC + NestJS</h2>\n<p>Exit les schémas REST ou GraphQL à maintenir. <strong>tRPC</strong> donne une <strong>API type-safe de bout en bout</strong> sans génération de code.</p>\n<pre><code class=\"language-typescript\">// Le type est inféré automatiquement côté client\r\nconst user = await trpc.user.getById.query({ id: \"123\" });\r\n// user est typé User, pas unknown\n</code></pre>\n<p>Pour les services complexes, <strong>NestJS</strong> structure le backend avec une architecture modulaire :</p>\n<ul>\n<li><strong>Domain-Driven Design</strong> natif avec les modules</li>\n<li><strong>Dependency Injection</strong> propre</li>\n<li>Écosystème riche : guards, interceptors, pipes</li>\n</ul>\n<h2>Le Temps Réel : Convex.dev</h2>\n<p><strong>Convex</strong> a changé ma façon de penser le backend. C'est une <strong>base de données réactive</strong> avec des fonctions serverless intégrées.</p>\n<pre><code class=\"language-mermaid\">flowchart TB\r\n    subgraph Client\r\n        A[Next.js App]\r\n    end\r\n    subgraph Convex\r\n        B[Realtime Database]\r\n        C[Server Functions]\r\n        D[Scheduled Jobs]\r\n    end\r\n    subgraph AI Layer\r\n        E[Pinecone]\r\n        F[Qdrant]\r\n        G[OpenAI]\r\n    end\r\n    \r\n    A &#x3C;-->|WebSocket| B\r\n    A --> C\r\n    C --> B\r\n    C --> E\r\n    C --> F\r\n    C --> G\r\n    D --> C\r\n    \r\n    style A fill:#FC5757,color:#fff\r\n    style B fill:#FC5757,color:#fff\r\n    style C fill:#1a1d24,stroke:#FC5757\n</code></pre>\n<p><strong>Pourquoi Convex ?</strong></p>\n<ul>\n<li><strong>Réactivité native</strong> : Les queries se mettent à jour automatiquement. Pas de polling, pas de cache invalidation manuelle.</li>\n<li><strong>Transactions ACID</strong> : Contrairement à Firebase, vos données sont cohérentes.</li>\n<li><strong>TypeScript natif</strong> : Le schéma de base génère les types automatiquement.</li>\n</ul>\n<h2>L'Intelligence : Pinecone + Qdrant</h2>\n<p>Pour les projets IA, j'utilise <strong>deux bases vectorielles</strong> selon le use case :</p>\n<p>| Critère | Pinecone | Qdrant |\r\n|---------|----------|--------|\r\n| <strong>Scaling</strong> | Serverless, 0 config | Self-hosted ou cloud |\r\n| <strong>Coût</strong> | Pay-per-query | Prévisible |\r\n| <strong>Latence</strong> | ~50ms | ~20ms (self-hosted) |\r\n| <strong>Filtres</strong> | Metadata basique | Filtres complexes |</p>\n<p><strong>Pinecone</strong> pour le MVP et le scaling automatique. <strong>Qdrant</strong> quand on veut du contrôle total et des filtres avancés.</p>\n<p>Les deux s'intègrent parfaitement avec un pipeline RAG :</p>\n<p>$$similarity(q, d) = \\frac{q \\cdot d}{|q| \\times |d|}$$</p>\n<h2>Le Déploiement : Vercel Edge + PWA</h2>\n<p><strong>Vercel</strong> n'est plus optionnel pour Next.js. Les <strong>Edge Functions</strong> permettent :</p>\n<ul>\n<li><strong>Middleware global</strong> : Auth, A/B testing, geolocation en &#x3C;1ms</li>\n<li><strong>ISR On-Demand</strong> : Revalidation ciblée sans rebuild complet</li>\n<li><strong>Analytics intégrés</strong> : Web Vitals en temps réel</li>\n</ul>\n<p>Pour l'expérience mobile, je transforme chaque app en <strong>PWA</strong> :</p>\n<ul>\n<li><strong>Service Workers</strong> : Offline-first, sync en background</li>\n<li><strong>Push Notifications</strong> : Engagement sans app native</li>\n<li><strong>Installation</strong> : Icône sur l'écran d'accueil</li>\n</ul>\n<h2>La Stack Complète</h2>\n<p>Voici comment tous ces éléments s'articulent :</p>\n<pre><code class=\"language-mermaid\">flowchart LR\r\n    subgraph Frontend\r\n        A[Next.js 16]\r\n        B[PWA Layer]\r\n    end\r\n    \r\n    subgraph API\r\n        C[tRPC Router]\r\n        D[NestJS Services]\r\n    end\r\n    \r\n    subgraph Data\r\n        E[Convex DB]\r\n        F[Pinecone/Qdrant]\r\n    end\r\n    \r\n    subgraph Infra\r\n        G[Vercel Edge]\r\n        H[OpenAI/Anthropic]\r\n    end\r\n    \r\n    A --> C\r\n    B --> A\r\n    C --> D\r\n    C --> E\r\n    D --> F\r\n    D --> H\r\n    G --> A\r\n    \r\n    style A fill:#FC5757,color:#fff\r\n    style E fill:#FC5757,color:#fff\r\n    style G fill:#1a1d24,stroke:#FC5757\n</code></pre>\n<h2>Pourquoi Cette Stack Gagne</h2>\n<ul>\n<li><strong>Time-to-Market</strong> : Du prototype au prod en 2 semaines, pas 2 mois.</li>\n<li><strong>Type-Safety</strong> : Zéro bug de typage entre frontend et backend.</li>\n<li><strong>Scalabilité</strong> : De 0 à 100k users sans rearchitecturer.</li>\n<li><strong>Coût</strong> : Serverless = on paie ce qu'on consomme.</li>\n<li><strong>DX</strong> : Hot reload instantané, erreurs explicites, debugging facile.</li>\n</ul>\n<hr>\n<p><strong>Leçon apprise</strong> : La meilleure stack n'est pas celle qui a le plus de features. C'est celle qui vous fait <strong>shipper plus vite</strong> tout en dormant tranquille. En 2026, cette combinaison Next.js + Convex + Vector DB est mon arme secrète.</p>"
  },
  "_id": "posts/stack-ia-2026-nextjs-convex-pinecone.md",
  "_raw": {
    "sourceFilePath": "posts/stack-ia-2026-nextjs-convex-pinecone.md",
    "sourceFileName": "stack-ia-2026-nextjs-convex-pinecone.md",
    "sourceFileDir": "posts",
    "contentType": "markdown",
    "flattenedPath": "posts/stack-ia-2026-nextjs-convex-pinecone"
  },
  "type": "Post",
  "url": "/blog/stack-ia-2026-nextjs-convex-pinecone",
  "slug": "stack-ia-2026-nextjs-convex-pinecone"
}