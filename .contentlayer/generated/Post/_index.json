[
  {
    "title": "Recherche IA : Pourquoi le \"tout-sémantique\" est un piège",
    "date": "2026-01-27T00:00:00.000Z",
    "image": "/vector-to-graph.png",
    "excerpt": "Le Vector Search seul ne suffit plus. Découvrez pourquoi le GraphRAG est la nouvelle norme pour une recherche IA vraiment intelligente.",
    "body": {
      "raw": "\nOn ne va pas se mentir : en 2026, brancher une base vectorielle et se dire \"mon moteur de recherche est intelligent\", c'est déjà être en retard. Le sémantique pur est une illusion de compréhension. Il est \"flou\" là où vos utilisateurs exigent de la précision.\n\nEn tant que Product Engineer, j'ai vu ce mur de près : **le sémantique trouve le contexte, mais il perd la structure.**\n\n## Le problème : L'IA est \"aveugle\" aux relations\n\nLe Vector Search transforme votre texte en points dans l'espace. C'est génial pour savoir que \"contrat\" est proche de \"accord\". Mais c'est incapable de comprendre que *\"Le Contrat A annule la Clause 3 du Contrat B\"*.\n\nPour une base vectorielle classique, ce sont juste des blocs de texte. Pour un utilisateur pro, c'est une erreur critique.\n\n## La nouvelle norme : Le GraphRAG\n\nPour dépasser ça, on ne se contente plus de fusionner du lexical et du sémantique. On passe au **GraphRAG** (Knowledge Graph Augmented Generation).\n\nL'idée ? On n'indexe plus seulement des morceaux de texte, on extrait des **entités** et des **relations**.\n\n```mermaid\nflowchart LR\n    Q[Query] --> VS[Vector Search]\n    Q --> KG[Knowledge Graph]\n    VS --> |Documents| RRF[RRF Fusion]\n    KG --> |Relations| RRF\n    RRF --> LLM[LLM Response]\n    \n    style Q fill:#FC5757,color:#fff\n    style RRF fill:#FC5757,color:#fff\n    style LLM fill:#1a1d24,stroke:#e62872\n```\n\n1. Le **Vector Search** localise les documents pertinents.\n2. Le **Knowledge Graph** navigue entre eux pour comprendre les liens logiques.\n3. La **Fusion (RRF)** vient ensuite équilibrer les scores pour présenter la réponse parfaite.\n\nOn utilise toujours l'algorithme RRF (Reciprocal Rank Fusion) pour garantir la pertinence :\n\n$$RRF_{score}(d) = \\sum_{r \\in R} \\frac{1}{k + r(d)}$$\n\n## Pourquoi c'est le futur de l'ingénierie\n\nEn 2026, le rôle d'un Product Engineer n'est plus de \"coder une recherche\", mais d'**architecturer un cerveau de données**.\n\n- **Précision chirurgicale** : Le graphe permet de répondre à des questions complexes de \"raisonnement\" que le sémantique rate.\n- **Coûts maîtrisés** : En ciblant mieux l'information grâce au graphe, on envoie moins de \"bruit\" au LLM, ce qui réduit drastiquement la consommation de tokens.\n- **Maintenabilité** : Une architecture hybride + graphe est bien plus facile à debugger qu'une boîte noire vectorielle.\n\n---\n\n**Leçon apprise** : Ne confiez pas votre recherche à une simple liste de vecteurs. Si vous voulez un système vraiment intelligent, donnez-lui une structure.\n",
      "html": "<p>On ne va pas se mentir : en 2026, brancher une base vectorielle et se dire \"mon moteur de recherche est intelligent\", c'est déjà être en retard. Le sémantique pur est une illusion de compréhension. Il est \"flou\" là où vos utilisateurs exigent de la précision.</p>\n<p>En tant que Product Engineer, j'ai vu ce mur de près : <strong>le sémantique trouve le contexte, mais il perd la structure.</strong></p>\n<h2>Le problème : L'IA est \"aveugle\" aux relations</h2>\n<p>Le Vector Search transforme votre texte en points dans l'espace. C'est génial pour savoir que \"contrat\" est proche de \"accord\". Mais c'est incapable de comprendre que <em>\"Le Contrat A annule la Clause 3 du Contrat B\"</em>.</p>\n<p>Pour une base vectorielle classique, ce sont juste des blocs de texte. Pour un utilisateur pro, c'est une erreur critique.</p>\n<h2>La nouvelle norme : Le GraphRAG</h2>\n<p>Pour dépasser ça, on ne se contente plus de fusionner du lexical et du sémantique. On passe au <strong>GraphRAG</strong> (Knowledge Graph Augmented Generation).</p>\n<p>L'idée ? On n'indexe plus seulement des morceaux de texte, on extrait des <strong>entités</strong> et des <strong>relations</strong>.</p>\n<pre><code class=\"language-mermaid\">flowchart LR\n    Q[Query] --> VS[Vector Search]\n    Q --> KG[Knowledge Graph]\n    VS --> |Documents| RRF[RRF Fusion]\n    KG --> |Relations| RRF\n    RRF --> LLM[LLM Response]\n    \n    style Q fill:#FC5757,color:#fff\n    style RRF fill:#FC5757,color:#fff\n    style LLM fill:#1a1d24,stroke:#e62872\n</code></pre>\n<ol>\n<li>Le <strong>Vector Search</strong> localise les documents pertinents.</li>\n<li>Le <strong>Knowledge Graph</strong> navigue entre eux pour comprendre les liens logiques.</li>\n<li>La <strong>Fusion (RRF)</strong> vient ensuite équilibrer les scores pour présenter la réponse parfaite.</li>\n</ol>\n<p>On utilise toujours l'algorithme RRF (Reciprocal Rank Fusion) pour garantir la pertinence :</p>\n<p>$$RRF_{score}(d) = \\sum_{r \\in R} \\frac{1}{k + r(d)}$$</p>\n<h2>Pourquoi c'est le futur de l'ingénierie</h2>\n<p>En 2026, le rôle d'un Product Engineer n'est plus de \"coder une recherche\", mais d'<strong>architecturer un cerveau de données</strong>.</p>\n<ul>\n<li><strong>Précision chirurgicale</strong> : Le graphe permet de répondre à des questions complexes de \"raisonnement\" que le sémantique rate.</li>\n<li><strong>Coûts maîtrisés</strong> : En ciblant mieux l'information grâce au graphe, on envoie moins de \"bruit\" au LLM, ce qui réduit drastiquement la consommation de tokens.</li>\n<li><strong>Maintenabilité</strong> : Une architecture hybride + graphe est bien plus facile à debugger qu'une boîte noire vectorielle.</li>\n</ul>\n<hr>\n<p><strong>Leçon apprise</strong> : Ne confiez pas votre recherche à une simple liste de vecteurs. Si vous voulez un système vraiment intelligent, donnez-lui une structure.</p>"
    },
    "_id": "posts/graphrag-recherche-ia-semantique-piege.md",
    "_raw": {
      "sourceFilePath": "posts/graphrag-recherche-ia-semantique-piege.md",
      "sourceFileName": "graphrag-recherche-ia-semantique-piege.md",
      "sourceFileDir": "posts",
      "contentType": "markdown",
      "flattenedPath": "posts/graphrag-recherche-ia-semantique-piege"
    },
    "type": "Post",
    "url": "/blog/graphrag-recherche-ia-semantique-piege",
    "slug": "graphrag-recherche-ia-semantique-piege"
  },
  {
    "title": "Ma Stack IA 2026 : L'Architecture qui Délivre",
    "date": "2026-01-28T00:00:00.000Z",
    "image": "/ma-stack.png",
    "excerpt": "Next.js 16, Convex, Pinecone, tRPC... Voici la stack que j'utilise pour shipper des apps IA production-ready en un temps record.\r",
    "body": {
      "raw": "\r\nAprès des dizaines de projets IA, j'ai convergé vers une stack qui coche toutes les cases : **DX de rêve**, **type-safety absolue**, et **scalabilité native**. Pas de compromis.\r\n\r\nEn tant que Product Engineer, je ne cherche pas la hype. Je cherche ce qui **shippe vite** et **tient la charge**. Voici mon arsenal 2026.\r\n\r\n## Le Frontend : Next.js 16 + TypeScript\r\n\r\n**Next.js 16** n'est plus un framework, c'est un **runtime**. Avec le Server Components par défaut, le Turbopack stable, et les **Partial Prerendering**, on atteint des performances qu'on croyait réservées aux apps natives.\r\n\r\n- **Turbopack** : Build 10x plus rapide que Webpack. Le HMR est instantané.\r\n- **Server Actions** : Plus besoin d'API routes pour les mutations simples.\r\n- **Edge Runtime** : Du code qui s'exécute à 50ms de l'utilisateur, partout dans le monde.\r\n\r\nLe tout avec **TypeScript strict**. Pas de `any`, pas de surprise en prod.\r\n\r\n## La Communication : tRPC + NestJS\r\n\r\nExit les schémas REST ou GraphQL à maintenir. **tRPC** donne une **API type-safe de bout en bout** sans génération de code.\r\n\r\n```typescript\r\n// Le type est inféré automatiquement côté client\r\nconst user = await trpc.user.getById.query({ id: \"123\" });\r\n// user est typé User, pas unknown\r\n```\r\n\r\nPour les services complexes, **NestJS** structure le backend avec une architecture modulaire :\r\n\r\n- **Domain-Driven Design** natif avec les modules\r\n- **Dependency Injection** propre\r\n- Écosystème riche : guards, interceptors, pipes\r\n\r\n## Le Temps Réel : Convex.dev\r\n\r\n**Convex** a changé ma façon de penser le backend. C'est une **base de données réactive** avec des fonctions serverless intégrées.\r\n\r\n```mermaid\r\nflowchart TB\r\n    subgraph Client\r\n        A[Next.js App]\r\n    end\r\n    subgraph Convex\r\n        B[Realtime Database]\r\n        C[Server Functions]\r\n        D[Scheduled Jobs]\r\n    end\r\n    subgraph AI Layer\r\n        E[Pinecone]\r\n        F[Qdrant]\r\n        G[OpenAI]\r\n    end\r\n    \r\n    A <-->|WebSocket| B\r\n    A --> C\r\n    C --> B\r\n    C --> E\r\n    C --> F\r\n    C --> G\r\n    D --> C\r\n    \r\n    style A fill:#FC5757,color:#fff\r\n    style B fill:#FC5757,color:#fff\r\n    style C fill:#1a1d24,stroke:#FC5757\r\n```\r\n\r\n**Pourquoi Convex ?**\r\n\r\n- **Réactivité native** : Les queries se mettent à jour automatiquement. Pas de polling, pas de cache invalidation manuelle.\r\n- **Transactions ACID** : Contrairement à Firebase, vos données sont cohérentes.\r\n- **TypeScript natif** : Le schéma de base génère les types automatiquement.\r\n\r\n## L'Intelligence : Pinecone + Qdrant\r\n\r\nPour les projets IA, j'utilise **deux bases vectorielles** selon le use case :\r\n\r\n| Critère | Pinecone | Qdrant |\r\n|---------|----------|--------|\r\n| **Scaling** | Serverless, 0 config | Self-hosted ou cloud |\r\n| **Coût** | Pay-per-query | Prévisible |\r\n| **Latence** | ~50ms | ~20ms (self-hosted) |\r\n| **Filtres** | Metadata basique | Filtres complexes |\r\n\r\n**Pinecone** pour le MVP et le scaling automatique. **Qdrant** quand on veut du contrôle total et des filtres avancés.\r\n\r\nLes deux s'intègrent parfaitement avec un pipeline RAG :\r\n\r\n$$similarity(q, d) = \\frac{q \\cdot d}{\\|q\\| \\times \\|d\\|}$$\r\n\r\n## Le Déploiement : Vercel Edge + PWA\r\n\r\n**Vercel** n'est plus optionnel pour Next.js. Les **Edge Functions** permettent :\r\n\r\n- **Middleware global** : Auth, A/B testing, geolocation en <1ms\r\n- **ISR On-Demand** : Revalidation ciblée sans rebuild complet\r\n- **Analytics intégrés** : Web Vitals en temps réel\r\n\r\nPour l'expérience mobile, je transforme chaque app en **PWA** :\r\n\r\n- **Service Workers** : Offline-first, sync en background\r\n- **Push Notifications** : Engagement sans app native\r\n- **Installation** : Icône sur l'écran d'accueil\r\n\r\n## La Stack Complète\r\n\r\nVoici comment tous ces éléments s'articulent :\r\n\r\n```mermaid\r\nflowchart LR\r\n    subgraph Frontend\r\n        A[Next.js 16]\r\n        B[PWA Layer]\r\n    end\r\n    \r\n    subgraph API\r\n        C[tRPC Router]\r\n        D[NestJS Services]\r\n    end\r\n    \r\n    subgraph Data\r\n        E[Convex DB]\r\n        F[Pinecone/Qdrant]\r\n    end\r\n    \r\n    subgraph Infra\r\n        G[Vercel Edge]\r\n        H[OpenAI/Anthropic]\r\n    end\r\n    \r\n    A --> C\r\n    B --> A\r\n    C --> D\r\n    C --> E\r\n    D --> F\r\n    D --> H\r\n    G --> A\r\n    \r\n    style A fill:#FC5757,color:#fff\r\n    style E fill:#FC5757,color:#fff\r\n    style G fill:#1a1d24,stroke:#FC5757\r\n```\r\n\r\n## Pourquoi Cette Stack Gagne\r\n\r\n- **Time-to-Market** : Du prototype au prod en 2 semaines, pas 2 mois.\r\n- **Type-Safety** : Zéro bug de typage entre frontend et backend.\r\n- **Scalabilité** : De 0 à 100k users sans rearchitecturer.\r\n- **Coût** : Serverless = on paie ce qu'on consomme.\r\n- **DX** : Hot reload instantané, erreurs explicites, debugging facile.\r\n\r\n---\r\n\r\n**Leçon apprise** : La meilleure stack n'est pas celle qui a le plus de features. C'est celle qui vous fait **shipper plus vite** tout en dormant tranquille. En 2026, cette combinaison Next.js + Convex + Vector DB est mon arme secrète.\r\n",
      "html": "<p>Après des dizaines de projets IA, j'ai convergé vers une stack qui coche toutes les cases : <strong>DX de rêve</strong>, <strong>type-safety absolue</strong>, et <strong>scalabilité native</strong>. Pas de compromis.</p>\n<p>En tant que Product Engineer, je ne cherche pas la hype. Je cherche ce qui <strong>shippe vite</strong> et <strong>tient la charge</strong>. Voici mon arsenal 2026.</p>\n<h2>Le Frontend : Next.js 16 + TypeScript</h2>\n<p><strong>Next.js 16</strong> n'est plus un framework, c'est un <strong>runtime</strong>. Avec le Server Components par défaut, le Turbopack stable, et les <strong>Partial Prerendering</strong>, on atteint des performances qu'on croyait réservées aux apps natives.</p>\n<ul>\n<li><strong>Turbopack</strong> : Build 10x plus rapide que Webpack. Le HMR est instantané.</li>\n<li><strong>Server Actions</strong> : Plus besoin d'API routes pour les mutations simples.</li>\n<li><strong>Edge Runtime</strong> : Du code qui s'exécute à 50ms de l'utilisateur, partout dans le monde.</li>\n</ul>\n<p>Le tout avec <strong>TypeScript strict</strong>. Pas de <code>any</code>, pas de surprise en prod.</p>\n<h2>La Communication : tRPC + NestJS</h2>\n<p>Exit les schémas REST ou GraphQL à maintenir. <strong>tRPC</strong> donne une <strong>API type-safe de bout en bout</strong> sans génération de code.</p>\n<pre><code class=\"language-typescript\">// Le type est inféré automatiquement côté client\r\nconst user = await trpc.user.getById.query({ id: \"123\" });\r\n// user est typé User, pas unknown\n</code></pre>\n<p>Pour les services complexes, <strong>NestJS</strong> structure le backend avec une architecture modulaire :</p>\n<ul>\n<li><strong>Domain-Driven Design</strong> natif avec les modules</li>\n<li><strong>Dependency Injection</strong> propre</li>\n<li>Écosystème riche : guards, interceptors, pipes</li>\n</ul>\n<h2>Le Temps Réel : Convex.dev</h2>\n<p><strong>Convex</strong> a changé ma façon de penser le backend. C'est une <strong>base de données réactive</strong> avec des fonctions serverless intégrées.</p>\n<pre><code class=\"language-mermaid\">flowchart TB\r\n    subgraph Client\r\n        A[Next.js App]\r\n    end\r\n    subgraph Convex\r\n        B[Realtime Database]\r\n        C[Server Functions]\r\n        D[Scheduled Jobs]\r\n    end\r\n    subgraph AI Layer\r\n        E[Pinecone]\r\n        F[Qdrant]\r\n        G[OpenAI]\r\n    end\r\n    \r\n    A &#x3C;-->|WebSocket| B\r\n    A --> C\r\n    C --> B\r\n    C --> E\r\n    C --> F\r\n    C --> G\r\n    D --> C\r\n    \r\n    style A fill:#FC5757,color:#fff\r\n    style B fill:#FC5757,color:#fff\r\n    style C fill:#1a1d24,stroke:#FC5757\n</code></pre>\n<p><strong>Pourquoi Convex ?</strong></p>\n<ul>\n<li><strong>Réactivité native</strong> : Les queries se mettent à jour automatiquement. Pas de polling, pas de cache invalidation manuelle.</li>\n<li><strong>Transactions ACID</strong> : Contrairement à Firebase, vos données sont cohérentes.</li>\n<li><strong>TypeScript natif</strong> : Le schéma de base génère les types automatiquement.</li>\n</ul>\n<h2>L'Intelligence : Pinecone + Qdrant</h2>\n<p>Pour les projets IA, j'utilise <strong>deux bases vectorielles</strong> selon le use case :</p>\n<p>| Critère | Pinecone | Qdrant |\r\n|---------|----------|--------|\r\n| <strong>Scaling</strong> | Serverless, 0 config | Self-hosted ou cloud |\r\n| <strong>Coût</strong> | Pay-per-query | Prévisible |\r\n| <strong>Latence</strong> | ~50ms | ~20ms (self-hosted) |\r\n| <strong>Filtres</strong> | Metadata basique | Filtres complexes |</p>\n<p><strong>Pinecone</strong> pour le MVP et le scaling automatique. <strong>Qdrant</strong> quand on veut du contrôle total et des filtres avancés.</p>\n<p>Les deux s'intègrent parfaitement avec un pipeline RAG :</p>\n<p>$$similarity(q, d) = \\frac{q \\cdot d}{|q| \\times |d|}$$</p>\n<h2>Le Déploiement : Vercel Edge + PWA</h2>\n<p><strong>Vercel</strong> n'est plus optionnel pour Next.js. Les <strong>Edge Functions</strong> permettent :</p>\n<ul>\n<li><strong>Middleware global</strong> : Auth, A/B testing, geolocation en &#x3C;1ms</li>\n<li><strong>ISR On-Demand</strong> : Revalidation ciblée sans rebuild complet</li>\n<li><strong>Analytics intégrés</strong> : Web Vitals en temps réel</li>\n</ul>\n<p>Pour l'expérience mobile, je transforme chaque app en <strong>PWA</strong> :</p>\n<ul>\n<li><strong>Service Workers</strong> : Offline-first, sync en background</li>\n<li><strong>Push Notifications</strong> : Engagement sans app native</li>\n<li><strong>Installation</strong> : Icône sur l'écran d'accueil</li>\n</ul>\n<h2>La Stack Complète</h2>\n<p>Voici comment tous ces éléments s'articulent :</p>\n<pre><code class=\"language-mermaid\">flowchart LR\r\n    subgraph Frontend\r\n        A[Next.js 16]\r\n        B[PWA Layer]\r\n    end\r\n    \r\n    subgraph API\r\n        C[tRPC Router]\r\n        D[NestJS Services]\r\n    end\r\n    \r\n    subgraph Data\r\n        E[Convex DB]\r\n        F[Pinecone/Qdrant]\r\n    end\r\n    \r\n    subgraph Infra\r\n        G[Vercel Edge]\r\n        H[OpenAI/Anthropic]\r\n    end\r\n    \r\n    A --> C\r\n    B --> A\r\n    C --> D\r\n    C --> E\r\n    D --> F\r\n    D --> H\r\n    G --> A\r\n    \r\n    style A fill:#FC5757,color:#fff\r\n    style E fill:#FC5757,color:#fff\r\n    style G fill:#1a1d24,stroke:#FC5757\n</code></pre>\n<h2>Pourquoi Cette Stack Gagne</h2>\n<ul>\n<li><strong>Time-to-Market</strong> : Du prototype au prod en 2 semaines, pas 2 mois.</li>\n<li><strong>Type-Safety</strong> : Zéro bug de typage entre frontend et backend.</li>\n<li><strong>Scalabilité</strong> : De 0 à 100k users sans rearchitecturer.</li>\n<li><strong>Coût</strong> : Serverless = on paie ce qu'on consomme.</li>\n<li><strong>DX</strong> : Hot reload instantané, erreurs explicites, debugging facile.</li>\n</ul>\n<hr>\n<p><strong>Leçon apprise</strong> : La meilleure stack n'est pas celle qui a le plus de features. C'est celle qui vous fait <strong>shipper plus vite</strong> tout en dormant tranquille. En 2026, cette combinaison Next.js + Convex + Vector DB est mon arme secrète.</p>"
    },
    "_id": "posts/stack-ia-2026-nextjs-convex-pinecone.md",
    "_raw": {
      "sourceFilePath": "posts/stack-ia-2026-nextjs-convex-pinecone.md",
      "sourceFileName": "stack-ia-2026-nextjs-convex-pinecone.md",
      "sourceFileDir": "posts",
      "contentType": "markdown",
      "flattenedPath": "posts/stack-ia-2026-nextjs-convex-pinecone"
    },
    "type": "Post",
    "url": "/blog/stack-ia-2026-nextjs-convex-pinecone",
    "slug": "stack-ia-2026-nextjs-convex-pinecone"
  },
  {
    "title": "10 Fonctionnalités Cachées de Convex que Personne n'Utilise",
    "date": "2026-01-28T00:00:00.000Z",
    "image": "/convex.png",
    "excerpt": "Scheduled Functions, Vector Search, HTTP Actions... Plongée dans les features avancées de Convex que même les devs expérimentés ignorent.\r",
    "body": {
      "raw": "\r\nConvex, c'est le backend qui a révolutionné ma façon de coder. Mais après des mois à creuser la doc, j'ai découvert des **pépites cachées** que 90% des développeurs n'exploitent pas.\r\n\r\nEn tant que Product Engineer, je vais vous révéler les **10 features qui changent tout**.\r\n\r\n## 1. Scheduled Functions : Le Cron Killer\r\n\r\nOubliez les cron jobs à configurer sur un serveur. Convex permet de **planifier des fonctions directement depuis votre code**.\r\n\r\n```typescript\r\n// Planifier une fonction dans 5 minutes\r\nawait ctx.scheduler.runAfter(5 * 60 * 1000, internal.emails.sendReminder, {\r\n  userId: args.userId,\r\n});\r\n\r\n// Planifier à une date précise\r\nawait ctx.scheduler.runAt(new Date(\"2026-02-01T09:00:00Z\"), internal.reports.generate, {\r\n  reportId: args.reportId,\r\n});\r\n```\r\n\r\n**La magie ?** Si votre mutation réussit, la fonction est **garantie** de s'exécuter. Si elle échoue, rien n'est planifié. Atomicité parfaite.\r\n\r\n- Jusqu'à **1000 fonctions** planifiées simultanément\r\n- Délai de quelques millisecondes à plusieurs années\r\n- Visible dans le dashboard Convex\r\n\r\n## 2. Cron Jobs Natifs\r\n\r\nPour les tâches récurrentes, Convex a son propre système de crons. Créez un fichier `convex/crons.ts` :\r\n\r\n```typescript\r\nimport { cronJobs } from \"convex/server\";\r\nimport { internal } from \"./_generated/api\";\r\n\r\nconst crons = cronJobs();\r\n\r\n// Toutes les heures\r\ncrons.interval(\"sync-data\", { hours: 1 }, internal.sync.pullFromAPI);\r\n\r\n// Chaque jour à 9h UTC\r\ncrons.daily(\"daily-report\", { hourUTC: 9, minuteUTC: 0 }, internal.reports.daily);\r\n\r\n// Syntaxe cron classique\r\ncrons.cron(\"cleanup\", \"0 0 * * 0\", internal.cleanup.weeklyPurge);\r\n\r\nexport default crons;\r\n```\r\n\r\n**Avantage vs cron traditionnel** : Pas de serveur à maintenir, logs intégrés, et vos jobs sont **versionnés** avec votre code.\r\n\r\n## 3. Vector Search Intégré\r\n\r\nPas besoin de Pinecone ou Qdrant pour un MVP. Convex a son propre **moteur de recherche vectorielle**.\r\n\r\n```typescript\r\n// schema.ts - Définir l'index vectoriel\r\nexport default defineSchema({\r\n  documents: defineTable({\r\n    content: v.string(),\r\n    embedding: v.array(v.float64()),\r\n  }).vectorIndex(\"by_embedding\", {\r\n    vectorField: \"embedding\",\r\n    dimensions: 1536, // OpenAI embeddings\r\n    filterFields: [\"category\"],\r\n  }),\r\n});\r\n```\r\n\r\n```typescript\r\n// Rechercher les documents similaires\r\nconst results = await ctx.vectorSearch(\"documents\", \"by_embedding\", {\r\n  vector: queryEmbedding,\r\n  limit: 10,\r\n  filter: (q) => q.eq(\"category\", \"tech\"),\r\n});\r\n```\r\n\r\n```mermaid\r\nflowchart LR\r\n    A[User Query] --> B[Generate Embedding]\r\n    B --> C[Vector Search]\r\n    C --> D[Top K Documents]\r\n    D --> E[LLM Context]\r\n    E --> F[AI Response]\r\n    \r\n    style A fill:#FC5757,color:#fff\r\n    style C fill:#FC5757,color:#fff\r\n    style F fill:#1a1d24,stroke:#FC5757\r\n```\r\n\r\n**Le plus ?** La recherche est **immédiatement cohérente**. Contrairement aux bases vectorielles externes, pas de délai de synchronisation.\r\n\r\n## 4. File Storage Sans Config\r\n\r\nUpload, stockage, et serving de fichiers en **3 lignes de code**. Pas de S3 à configurer.\r\n\r\n```typescript\r\n// Générer une URL d'upload (valide 1h)\r\nconst uploadUrl = await ctx.storage.generateUploadUrl();\r\n\r\n// Récupérer l'URL publique d'un fichier\r\nconst fileUrl = await ctx.storage.getUrl(storageId);\r\n\r\n// Supprimer un fichier\r\nawait ctx.storage.delete(storageId);\r\n```\r\n\r\n**Features cachées :**\r\n- Support de **tous les types de fichiers**\r\n- URLs signées avec expiration\r\n- Streaming depuis les HTTP Actions\r\n- Métadonnées accessibles\r\n\r\n## 5. HTTP Actions : Votre API REST\r\n\r\nConvex peut exposer des **endpoints HTTP** pour recevoir des webhooks ou créer une API REST.\r\n\r\n```typescript\r\n// convex/http.ts\r\nimport { httpRouter } from \"convex/server\";\r\nimport { httpAction } from \"./_generated/server\";\r\n\r\nconst http = httpRouter();\r\n\r\nhttp.route({\r\n  path: \"/webhooks/stripe\",\r\n  method: \"POST\",\r\n  handler: httpAction(async (ctx, request) => {\r\n    const body = await request.json();\r\n    const signature = request.headers.get(\"stripe-signature\");\r\n    \r\n    // Valider et traiter le webhook\r\n    await ctx.runMutation(internal.payments.processWebhook, {\r\n      event: body,\r\n    });\r\n    \r\n    return new Response(\"OK\", { status: 200 });\r\n  }),\r\n});\r\n\r\nexport default http;\r\n```\r\n\r\nVos endpoints sont accessibles sur `https://votre-projet.convex.site/webhooks/stripe`.\r\n\r\n**Use cases :**\r\n- Webhooks (Stripe, GitHub, Discord)\r\n- API publique pour apps tierces\r\n- Intégration avec Zapier/n8n\r\n\r\n## 6. Optimistic Updates\r\n\r\nRendez votre UI **instantanément réactive** avant même que le serveur réponde.\r\n\r\n```typescript\r\nconst addTodo = useMutation(api.todos.add).withOptimisticUpdate(\r\n  (localStore, args) => {\r\n    const currentTodos = localStore.getQuery(api.todos.list);\r\n    if (currentTodos !== undefined) {\r\n      localStore.setQuery(api.todos.list, {}, [\r\n        ...currentTodos,\r\n        { _id: \"temp\", text: args.text, completed: false },\r\n      ]);\r\n    }\r\n  }\r\n);\r\n```\r\n\r\n**Comment ça marche ?**\r\n\r\n```mermaid\r\nsequenceDiagram\r\n    participant UI\r\n    participant LocalStore\r\n    participant Convex\r\n    \r\n    UI->>LocalStore: Optimistic Update\r\n    LocalStore->>UI: UI Updated (instant)\r\n    UI->>Convex: Mutation Request\r\n    Convex->>Convex: Process Mutation\r\n    Convex->>LocalStore: Real Data\r\n    LocalStore->>UI: Reconcile (auto)\r\n```\r\n\r\nSi le serveur renvoie des données différentes, Convex **rollback automatiquement** l'update optimiste.\r\n\r\n## 7. Internal Functions : L'Encapsulation Parfaite\r\n\r\nLes `internalQuery`, `internalMutation`, et `internalAction` sont **invisibles** côté client. Parfait pour la logique sensible.\r\n\r\n```typescript\r\n// Accessible uniquement depuis le backend\r\nexport const chargeCustomer = internalMutation({\r\n  args: { userId: v.id(\"users\"), amount: v.number() },\r\n  handler: async (ctx, args) => {\r\n    // Logique de facturation sensible\r\n    const user = await ctx.db.get(args.userId);\r\n    await stripe.charges.create({ amount: args.amount, customer: user.stripeId });\r\n    await ctx.db.patch(args.userId, { lastCharged: Date.now() });\r\n  },\r\n});\r\n\r\n// Appel depuis une autre fonction\r\nawait ctx.runMutation(internal.billing.chargeCustomer, { userId, amount: 1999 });\r\n```\r\n\r\n**Sécurité** : Ces fonctions n'apparaissent pas dans l'objet `api` exposé au client. Impossible de les appeler depuis le frontend.\r\n\r\n## 8. Pagination Réactive\r\n\r\nLa pagination Convex est **fully reactive**. Quand un document change, votre page se met à jour automatiquement.\r\n\r\n```typescript\r\n// Backend\r\nexport const listMessages = query({\r\n  args: { paginationOpts: paginationOptsValidator },\r\n  handler: async (ctx, args) => {\r\n    return await ctx.db\r\n      .query(\"messages\")\r\n      .order(\"desc\")\r\n      .paginate(args.paginationOpts);\r\n  },\r\n});\r\n\r\n// Frontend - Infinite scroll automatique\r\nconst { results, status, loadMore } = usePaginatedQuery(\r\n  api.messages.list,\r\n  {},\r\n  { initialNumItems: 20 }\r\n);\r\n```\r\n\r\n**Le trick ?** Combinez avec l'Intersection Observer pour un **infinite scroll parfait** :\r\n\r\n```typescript\r\nuseEffect(() => {\r\n  const observer = new IntersectionObserver(\r\n    ([entry]) => entry.isIntersecting && status === \"CanLoadMore\" && loadMore(20)\r\n  );\r\n  observer.observe(sentinelRef.current);\r\n  return () => observer.disconnect();\r\n}, [status, loadMore]);\r\n```\r\n\r\n## 9. Components : Modules Réutilisables\r\n\r\nConvex permet de créer des **composants backend** packagés comme des modules NPM.\r\n\r\n```typescript\r\n// Installation\r\nnpm install @convex-dev/aggregate\r\n\r\n// Utilisation\r\nimport { Aggregate } from \"@convex-dev/aggregate\";\r\n\r\nconst aggregate = new Aggregate<number>(components.aggregate, {\r\n  sortKey: (doc) => doc.createdAt,\r\n  sumValue: (doc) => doc.amount,\r\n});\r\n\r\n// Obtenir des stats en temps réel\r\nconst stats = await aggregate.sum(ctx, { prefix: [\"sales\", \"2026\"] });\r\n```\r\n\r\n**Components officiels disponibles :**\r\n- `@convex-dev/aggregate` - Agrégations temps réel\r\n- `@convex-dev/auth` - Authentification complète\r\n- `@convex-dev/rate-limiter` - Rate limiting\r\n- `@convex-dev/crons` - Crons avancés\r\n\r\n## 10. Validation avec Zod\r\n\r\nCombinez la puissance de **Zod** avec Convex pour une validation avancée :\r\n\r\n```typescript\r\nimport { zCustomMutation } from \"convex-helpers/server/zod\";\r\nimport { z } from \"zod\";\r\n\r\nconst mutation = zCustomMutation(baseMutation);\r\n\r\nexport const createUser = mutation({\r\n  args: {\r\n    email: z.string().email(),\r\n    age: z.number().min(18).max(120),\r\n    preferences: z.object({\r\n      theme: z.enum([\"light\", \"dark\"]),\r\n      notifications: z.boolean(),\r\n    }),\r\n  },\r\n  handler: async (ctx, args) => {\r\n    // args est parfaitement typé et validé\r\n    return await ctx.db.insert(\"users\", args);\r\n  },\r\n});\r\n```\r\n\r\n**Avantages vs validators natifs :**\r\n- Validations complexes (regex, min/max, enums)\r\n- Messages d'erreur personnalisés\r\n- Transformations de données\r\n- Réutilisation des schémas\r\n\r\n---\r\n\r\n## Récapitulatif\r\n\r\n| Feature | Use Case | Impact |\r\n|---------|----------|--------|\r\n| **Scheduled Functions** | Emails, rappels, jobs différés | ⭐⭐⭐⭐⭐ |\r\n| **Vector Search** | RAG, semantic search | ⭐⭐⭐⭐⭐ |\r\n| **HTTP Actions** | Webhooks, API REST | ⭐⭐⭐⭐ |\r\n| **Optimistic Updates** | UX instantanée | ⭐⭐⭐⭐ |\r\n| **File Storage** | Upload/download | ⭐⭐⭐⭐ |\r\n| **Components** | Code réutilisable | ⭐⭐⭐ |\r\n\r\n---\r\n\r\n**Leçon apprise** : Convex n'est pas juste une \"base de données réactive\". C'est un **backend complet** qui remplace Supabase, Firebase, et même certains services AWS. Creusez la doc, les pépites sont partout.\r\n",
      "html": "<p>Convex, c'est le backend qui a révolutionné ma façon de coder. Mais après des mois à creuser la doc, j'ai découvert des <strong>pépites cachées</strong> que 90% des développeurs n'exploitent pas.</p>\n<p>En tant que Product Engineer, je vais vous révéler les <strong>10 features qui changent tout</strong>.</p>\n<h2>1. Scheduled Functions : Le Cron Killer</h2>\n<p>Oubliez les cron jobs à configurer sur un serveur. Convex permet de <strong>planifier des fonctions directement depuis votre code</strong>.</p>\n<pre><code class=\"language-typescript\">// Planifier une fonction dans 5 minutes\r\nawait ctx.scheduler.runAfter(5 * 60 * 1000, internal.emails.sendReminder, {\r\n  userId: args.userId,\r\n});\r\n\r\n// Planifier à une date précise\r\nawait ctx.scheduler.runAt(new Date(\"2026-02-01T09:00:00Z\"), internal.reports.generate, {\r\n  reportId: args.reportId,\r\n});\n</code></pre>\n<p><strong>La magie ?</strong> Si votre mutation réussit, la fonction est <strong>garantie</strong> de s'exécuter. Si elle échoue, rien n'est planifié. Atomicité parfaite.</p>\n<ul>\n<li>Jusqu'à <strong>1000 fonctions</strong> planifiées simultanément</li>\n<li>Délai de quelques millisecondes à plusieurs années</li>\n<li>Visible dans le dashboard Convex</li>\n</ul>\n<h2>2. Cron Jobs Natifs</h2>\n<p>Pour les tâches récurrentes, Convex a son propre système de crons. Créez un fichier <code>convex/crons.ts</code> :</p>\n<pre><code class=\"language-typescript\">import { cronJobs } from \"convex/server\";\r\nimport { internal } from \"./_generated/api\";\r\n\r\nconst crons = cronJobs();\r\n\r\n// Toutes les heures\r\ncrons.interval(\"sync-data\", { hours: 1 }, internal.sync.pullFromAPI);\r\n\r\n// Chaque jour à 9h UTC\r\ncrons.daily(\"daily-report\", { hourUTC: 9, minuteUTC: 0 }, internal.reports.daily);\r\n\r\n// Syntaxe cron classique\r\ncrons.cron(\"cleanup\", \"0 0 * * 0\", internal.cleanup.weeklyPurge);\r\n\r\nexport default crons;\n</code></pre>\n<p><strong>Avantage vs cron traditionnel</strong> : Pas de serveur à maintenir, logs intégrés, et vos jobs sont <strong>versionnés</strong> avec votre code.</p>\n<h2>3. Vector Search Intégré</h2>\n<p>Pas besoin de Pinecone ou Qdrant pour un MVP. Convex a son propre <strong>moteur de recherche vectorielle</strong>.</p>\n<pre><code class=\"language-typescript\">// schema.ts - Définir l'index vectoriel\r\nexport default defineSchema({\r\n  documents: defineTable({\r\n    content: v.string(),\r\n    embedding: v.array(v.float64()),\r\n  }).vectorIndex(\"by_embedding\", {\r\n    vectorField: \"embedding\",\r\n    dimensions: 1536, // OpenAI embeddings\r\n    filterFields: [\"category\"],\r\n  }),\r\n});\n</code></pre>\n<pre><code class=\"language-typescript\">// Rechercher les documents similaires\r\nconst results = await ctx.vectorSearch(\"documents\", \"by_embedding\", {\r\n  vector: queryEmbedding,\r\n  limit: 10,\r\n  filter: (q) => q.eq(\"category\", \"tech\"),\r\n});\n</code></pre>\n<pre><code class=\"language-mermaid\">flowchart LR\r\n    A[User Query] --> B[Generate Embedding]\r\n    B --> C[Vector Search]\r\n    C --> D[Top K Documents]\r\n    D --> E[LLM Context]\r\n    E --> F[AI Response]\r\n    \r\n    style A fill:#FC5757,color:#fff\r\n    style C fill:#FC5757,color:#fff\r\n    style F fill:#1a1d24,stroke:#FC5757\n</code></pre>\n<p><strong>Le plus ?</strong> La recherche est <strong>immédiatement cohérente</strong>. Contrairement aux bases vectorielles externes, pas de délai de synchronisation.</p>\n<h2>4. File Storage Sans Config</h2>\n<p>Upload, stockage, et serving de fichiers en <strong>3 lignes de code</strong>. Pas de S3 à configurer.</p>\n<pre><code class=\"language-typescript\">// Générer une URL d'upload (valide 1h)\r\nconst uploadUrl = await ctx.storage.generateUploadUrl();\r\n\r\n// Récupérer l'URL publique d'un fichier\r\nconst fileUrl = await ctx.storage.getUrl(storageId);\r\n\r\n// Supprimer un fichier\r\nawait ctx.storage.delete(storageId);\n</code></pre>\n<p><strong>Features cachées :</strong></p>\n<ul>\n<li>Support de <strong>tous les types de fichiers</strong></li>\n<li>URLs signées avec expiration</li>\n<li>Streaming depuis les HTTP Actions</li>\n<li>Métadonnées accessibles</li>\n</ul>\n<h2>5. HTTP Actions : Votre API REST</h2>\n<p>Convex peut exposer des <strong>endpoints HTTP</strong> pour recevoir des webhooks ou créer une API REST.</p>\n<pre><code class=\"language-typescript\">// convex/http.ts\r\nimport { httpRouter } from \"convex/server\";\r\nimport { httpAction } from \"./_generated/server\";\r\n\r\nconst http = httpRouter();\r\n\r\nhttp.route({\r\n  path: \"/webhooks/stripe\",\r\n  method: \"POST\",\r\n  handler: httpAction(async (ctx, request) => {\r\n    const body = await request.json();\r\n    const signature = request.headers.get(\"stripe-signature\");\r\n    \r\n    // Valider et traiter le webhook\r\n    await ctx.runMutation(internal.payments.processWebhook, {\r\n      event: body,\r\n    });\r\n    \r\n    return new Response(\"OK\", { status: 200 });\r\n  }),\r\n});\r\n\r\nexport default http;\n</code></pre>\n<p>Vos endpoints sont accessibles sur <code>https://votre-projet.convex.site/webhooks/stripe</code>.</p>\n<p><strong>Use cases :</strong></p>\n<ul>\n<li>Webhooks (Stripe, GitHub, Discord)</li>\n<li>API publique pour apps tierces</li>\n<li>Intégration avec Zapier/n8n</li>\n</ul>\n<h2>6. Optimistic Updates</h2>\n<p>Rendez votre UI <strong>instantanément réactive</strong> avant même que le serveur réponde.</p>\n<pre><code class=\"language-typescript\">const addTodo = useMutation(api.todos.add).withOptimisticUpdate(\r\n  (localStore, args) => {\r\n    const currentTodos = localStore.getQuery(api.todos.list);\r\n    if (currentTodos !== undefined) {\r\n      localStore.setQuery(api.todos.list, {}, [\r\n        ...currentTodos,\r\n        { _id: \"temp\", text: args.text, completed: false },\r\n      ]);\r\n    }\r\n  }\r\n);\n</code></pre>\n<p><strong>Comment ça marche ?</strong></p>\n<pre><code class=\"language-mermaid\">sequenceDiagram\r\n    participant UI\r\n    participant LocalStore\r\n    participant Convex\r\n    \r\n    UI->>LocalStore: Optimistic Update\r\n    LocalStore->>UI: UI Updated (instant)\r\n    UI->>Convex: Mutation Request\r\n    Convex->>Convex: Process Mutation\r\n    Convex->>LocalStore: Real Data\r\n    LocalStore->>UI: Reconcile (auto)\n</code></pre>\n<p>Si le serveur renvoie des données différentes, Convex <strong>rollback automatiquement</strong> l'update optimiste.</p>\n<h2>7. Internal Functions : L'Encapsulation Parfaite</h2>\n<p>Les <code>internalQuery</code>, <code>internalMutation</code>, et <code>internalAction</code> sont <strong>invisibles</strong> côté client. Parfait pour la logique sensible.</p>\n<pre><code class=\"language-typescript\">// Accessible uniquement depuis le backend\r\nexport const chargeCustomer = internalMutation({\r\n  args: { userId: v.id(\"users\"), amount: v.number() },\r\n  handler: async (ctx, args) => {\r\n    // Logique de facturation sensible\r\n    const user = await ctx.db.get(args.userId);\r\n    await stripe.charges.create({ amount: args.amount, customer: user.stripeId });\r\n    await ctx.db.patch(args.userId, { lastCharged: Date.now() });\r\n  },\r\n});\r\n\r\n// Appel depuis une autre fonction\r\nawait ctx.runMutation(internal.billing.chargeCustomer, { userId, amount: 1999 });\n</code></pre>\n<p><strong>Sécurité</strong> : Ces fonctions n'apparaissent pas dans l'objet <code>api</code> exposé au client. Impossible de les appeler depuis le frontend.</p>\n<h2>8. Pagination Réactive</h2>\n<p>La pagination Convex est <strong>fully reactive</strong>. Quand un document change, votre page se met à jour automatiquement.</p>\n<pre><code class=\"language-typescript\">// Backend\r\nexport const listMessages = query({\r\n  args: { paginationOpts: paginationOptsValidator },\r\n  handler: async (ctx, args) => {\r\n    return await ctx.db\r\n      .query(\"messages\")\r\n      .order(\"desc\")\r\n      .paginate(args.paginationOpts);\r\n  },\r\n});\r\n\r\n// Frontend - Infinite scroll automatique\r\nconst { results, status, loadMore } = usePaginatedQuery(\r\n  api.messages.list,\r\n  {},\r\n  { initialNumItems: 20 }\r\n);\n</code></pre>\n<p><strong>Le trick ?</strong> Combinez avec l'Intersection Observer pour un <strong>infinite scroll parfait</strong> :</p>\n<pre><code class=\"language-typescript\">useEffect(() => {\r\n  const observer = new IntersectionObserver(\r\n    ([entry]) => entry.isIntersecting &#x26;&#x26; status === \"CanLoadMore\" &#x26;&#x26; loadMore(20)\r\n  );\r\n  observer.observe(sentinelRef.current);\r\n  return () => observer.disconnect();\r\n}, [status, loadMore]);\n</code></pre>\n<h2>9. Components : Modules Réutilisables</h2>\n<p>Convex permet de créer des <strong>composants backend</strong> packagés comme des modules NPM.</p>\n<pre><code class=\"language-typescript\">// Installation\r\nnpm install @convex-dev/aggregate\r\n\r\n// Utilisation\r\nimport { Aggregate } from \"@convex-dev/aggregate\";\r\n\r\nconst aggregate = new Aggregate&#x3C;number>(components.aggregate, {\r\n  sortKey: (doc) => doc.createdAt,\r\n  sumValue: (doc) => doc.amount,\r\n});\r\n\r\n// Obtenir des stats en temps réel\r\nconst stats = await aggregate.sum(ctx, { prefix: [\"sales\", \"2026\"] });\n</code></pre>\n<p><strong>Components officiels disponibles :</strong></p>\n<ul>\n<li><code>@convex-dev/aggregate</code> - Agrégations temps réel</li>\n<li><code>@convex-dev/auth</code> - Authentification complète</li>\n<li><code>@convex-dev/rate-limiter</code> - Rate limiting</li>\n<li><code>@convex-dev/crons</code> - Crons avancés</li>\n</ul>\n<h2>10. Validation avec Zod</h2>\n<p>Combinez la puissance de <strong>Zod</strong> avec Convex pour une validation avancée :</p>\n<pre><code class=\"language-typescript\">import { zCustomMutation } from \"convex-helpers/server/zod\";\r\nimport { z } from \"zod\";\r\n\r\nconst mutation = zCustomMutation(baseMutation);\r\n\r\nexport const createUser = mutation({\r\n  args: {\r\n    email: z.string().email(),\r\n    age: z.number().min(18).max(120),\r\n    preferences: z.object({\r\n      theme: z.enum([\"light\", \"dark\"]),\r\n      notifications: z.boolean(),\r\n    }),\r\n  },\r\n  handler: async (ctx, args) => {\r\n    // args est parfaitement typé et validé\r\n    return await ctx.db.insert(\"users\", args);\r\n  },\r\n});\n</code></pre>\n<p><strong>Avantages vs validators natifs :</strong></p>\n<ul>\n<li>Validations complexes (regex, min/max, enums)</li>\n<li>Messages d'erreur personnalisés</li>\n<li>Transformations de données</li>\n<li>Réutilisation des schémas</li>\n</ul>\n<hr>\n<h2>Récapitulatif</h2>\n<p>| Feature | Use Case | Impact |\r\n|---------|----------|--------|\r\n| <strong>Scheduled Functions</strong> | Emails, rappels, jobs différés | ⭐⭐⭐⭐⭐ |\r\n| <strong>Vector Search</strong> | RAG, semantic search | ⭐⭐⭐⭐⭐ |\r\n| <strong>HTTP Actions</strong> | Webhooks, API REST | ⭐⭐⭐⭐ |\r\n| <strong>Optimistic Updates</strong> | UX instantanée | ⭐⭐⭐⭐ |\r\n| <strong>File Storage</strong> | Upload/download | ⭐⭐⭐⭐ |\r\n| <strong>Components</strong> | Code réutilisable | ⭐⭐⭐ |</p>\n<hr>\n<p><strong>Leçon apprise</strong> : Convex n'est pas juste une \"base de données réactive\". C'est un <strong>backend complet</strong> qui remplace Supabase, Firebase, et même certains services AWS. Creusez la doc, les pépites sont partout.</p>"
    },
    "_id": "posts/convex-fonctionnalites-cachees-2026.md",
    "_raw": {
      "sourceFilePath": "posts/convex-fonctionnalites-cachees-2026.md",
      "sourceFileName": "convex-fonctionnalites-cachees-2026.md",
      "sourceFileDir": "posts",
      "contentType": "markdown",
      "flattenedPath": "posts/convex-fonctionnalites-cachees-2026"
    },
    "type": "Post",
    "url": "/blog/convex-fonctionnalites-cachees-2026",
    "slug": "convex-fonctionnalites-cachees-2026"
  }
]