{
  "title": "10 Fonctionnalités Cachées de Convex que Personne n'Utilise",
  "date": "2026-01-28T00:00:00.000Z",
  "image": "/convex.png",
  "excerpt": "Scheduled Functions, Vector Search, HTTP Actions... Plongée dans les features avancées de Convex que même les devs expérimentés ignorent.\r",
  "body": {
    "raw": "\r\nConvex, c'est le backend qui a révolutionné ma façon de coder. Mais après des mois à creuser la doc, j'ai découvert des **pépites cachées** que 90% des développeurs n'exploitent pas.\r\n\r\nEn tant que Product Engineer, je vais vous révéler les **10 features qui changent tout**.\r\n\r\n## 1. Scheduled Functions : Le Cron Killer\r\n\r\nOubliez les cron jobs à configurer sur un serveur. Convex permet de **planifier des fonctions directement depuis votre code**.\r\n\r\n```typescript\r\n// Planifier une fonction dans 5 minutes\r\nawait ctx.scheduler.runAfter(5 * 60 * 1000, internal.emails.sendReminder, {\r\n  userId: args.userId,\r\n});\r\n\r\n// Planifier à une date précise\r\nawait ctx.scheduler.runAt(new Date(\"2026-02-01T09:00:00Z\"), internal.reports.generate, {\r\n  reportId: args.reportId,\r\n});\r\n```\r\n\r\n**La magie ?** Si votre mutation réussit, la fonction est **garantie** de s'exécuter. Si elle échoue, rien n'est planifié. Atomicité parfaite.\r\n\r\n- Jusqu'à **1000 fonctions** planifiées simultanément\r\n- Délai de quelques millisecondes à plusieurs années\r\n- Visible dans le dashboard Convex\r\n\r\n## 2. Cron Jobs Natifs\r\n\r\nPour les tâches récurrentes, Convex a son propre système de crons. Créez un fichier `convex/crons.ts` :\r\n\r\n```typescript\r\nimport { cronJobs } from \"convex/server\";\r\nimport { internal } from \"./_generated/api\";\r\n\r\nconst crons = cronJobs();\r\n\r\n// Toutes les heures\r\ncrons.interval(\"sync-data\", { hours: 1 }, internal.sync.pullFromAPI);\r\n\r\n// Chaque jour à 9h UTC\r\ncrons.daily(\"daily-report\", { hourUTC: 9, minuteUTC: 0 }, internal.reports.daily);\r\n\r\n// Syntaxe cron classique\r\ncrons.cron(\"cleanup\", \"0 0 * * 0\", internal.cleanup.weeklyPurge);\r\n\r\nexport default crons;\r\n```\r\n\r\n**Avantage vs cron traditionnel** : Pas de serveur à maintenir, logs intégrés, et vos jobs sont **versionnés** avec votre code.\r\n\r\n## 3. Vector Search Intégré\r\n\r\nPas besoin de Pinecone ou Qdrant pour un MVP. Convex a son propre **moteur de recherche vectorielle**.\r\n\r\n```typescript\r\n// schema.ts - Définir l'index vectoriel\r\nexport default defineSchema({\r\n  documents: defineTable({\r\n    content: v.string(),\r\n    embedding: v.array(v.float64()),\r\n  }).vectorIndex(\"by_embedding\", {\r\n    vectorField: \"embedding\",\r\n    dimensions: 1536, // OpenAI embeddings\r\n    filterFields: [\"category\"],\r\n  }),\r\n});\r\n```\r\n\r\n```typescript\r\n// Rechercher les documents similaires\r\nconst results = await ctx.vectorSearch(\"documents\", \"by_embedding\", {\r\n  vector: queryEmbedding,\r\n  limit: 10,\r\n  filter: (q) => q.eq(\"category\", \"tech\"),\r\n});\r\n```\r\n\r\n```mermaid\r\nflowchart LR\r\n    A[User Query] --> B[Generate Embedding]\r\n    B --> C[Vector Search]\r\n    C --> D[Top K Documents]\r\n    D --> E[LLM Context]\r\n    E --> F[AI Response]\r\n    \r\n    style A fill:#FC5757,color:#fff\r\n    style C fill:#FC5757,color:#fff\r\n    style F fill:#1a1d24,stroke:#FC5757\r\n```\r\n\r\n**Le plus ?** La recherche est **immédiatement cohérente**. Contrairement aux bases vectorielles externes, pas de délai de synchronisation.\r\n\r\n## 4. File Storage Sans Config\r\n\r\nUpload, stockage, et serving de fichiers en **3 lignes de code**. Pas de S3 à configurer.\r\n\r\n```typescript\r\n// Générer une URL d'upload (valide 1h)\r\nconst uploadUrl = await ctx.storage.generateUploadUrl();\r\n\r\n// Récupérer l'URL publique d'un fichier\r\nconst fileUrl = await ctx.storage.getUrl(storageId);\r\n\r\n// Supprimer un fichier\r\nawait ctx.storage.delete(storageId);\r\n```\r\n\r\n**Features cachées :**\r\n- Support de **tous les types de fichiers**\r\n- URLs signées avec expiration\r\n- Streaming depuis les HTTP Actions\r\n- Métadonnées accessibles\r\n\r\n## 5. HTTP Actions : Votre API REST\r\n\r\nConvex peut exposer des **endpoints HTTP** pour recevoir des webhooks ou créer une API REST.\r\n\r\n```typescript\r\n// convex/http.ts\r\nimport { httpRouter } from \"convex/server\";\r\nimport { httpAction } from \"./_generated/server\";\r\n\r\nconst http = httpRouter();\r\n\r\nhttp.route({\r\n  path: \"/webhooks/stripe\",\r\n  method: \"POST\",\r\n  handler: httpAction(async (ctx, request) => {\r\n    const body = await request.json();\r\n    const signature = request.headers.get(\"stripe-signature\");\r\n    \r\n    // Valider et traiter le webhook\r\n    await ctx.runMutation(internal.payments.processWebhook, {\r\n      event: body,\r\n    });\r\n    \r\n    return new Response(\"OK\", { status: 200 });\r\n  }),\r\n});\r\n\r\nexport default http;\r\n```\r\n\r\nVos endpoints sont accessibles sur `https://votre-projet.convex.site/webhooks/stripe`.\r\n\r\n**Use cases :**\r\n- Webhooks (Stripe, GitHub, Discord)\r\n- API publique pour apps tierces\r\n- Intégration avec Zapier/n8n\r\n\r\n## 6. Optimistic Updates\r\n\r\nRendez votre UI **instantanément réactive** avant même que le serveur réponde.\r\n\r\n```typescript\r\nconst addTodo = useMutation(api.todos.add).withOptimisticUpdate(\r\n  (localStore, args) => {\r\n    const currentTodos = localStore.getQuery(api.todos.list);\r\n    if (currentTodos !== undefined) {\r\n      localStore.setQuery(api.todos.list, {}, [\r\n        ...currentTodos,\r\n        { _id: \"temp\", text: args.text, completed: false },\r\n      ]);\r\n    }\r\n  }\r\n);\r\n```\r\n\r\n**Comment ça marche ?**\r\n\r\n```mermaid\r\nsequenceDiagram\r\n    participant UI\r\n    participant LocalStore\r\n    participant Convex\r\n    \r\n    UI->>LocalStore: Optimistic Update\r\n    LocalStore->>UI: UI Updated (instant)\r\n    UI->>Convex: Mutation Request\r\n    Convex->>Convex: Process Mutation\r\n    Convex->>LocalStore: Real Data\r\n    LocalStore->>UI: Reconcile (auto)\r\n```\r\n\r\nSi le serveur renvoie des données différentes, Convex **rollback automatiquement** l'update optimiste.\r\n\r\n## 7. Internal Functions : L'Encapsulation Parfaite\r\n\r\nLes `internalQuery`, `internalMutation`, et `internalAction` sont **invisibles** côté client. Parfait pour la logique sensible.\r\n\r\n```typescript\r\n// Accessible uniquement depuis le backend\r\nexport const chargeCustomer = internalMutation({\r\n  args: { userId: v.id(\"users\"), amount: v.number() },\r\n  handler: async (ctx, args) => {\r\n    // Logique de facturation sensible\r\n    const user = await ctx.db.get(args.userId);\r\n    await stripe.charges.create({ amount: args.amount, customer: user.stripeId });\r\n    await ctx.db.patch(args.userId, { lastCharged: Date.now() });\r\n  },\r\n});\r\n\r\n// Appel depuis une autre fonction\r\nawait ctx.runMutation(internal.billing.chargeCustomer, { userId, amount: 1999 });\r\n```\r\n\r\n**Sécurité** : Ces fonctions n'apparaissent pas dans l'objet `api` exposé au client. Impossible de les appeler depuis le frontend.\r\n\r\n## 8. Pagination Réactive\r\n\r\nLa pagination Convex est **fully reactive**. Quand un document change, votre page se met à jour automatiquement.\r\n\r\n```typescript\r\n// Backend\r\nexport const listMessages = query({\r\n  args: { paginationOpts: paginationOptsValidator },\r\n  handler: async (ctx, args) => {\r\n    return await ctx.db\r\n      .query(\"messages\")\r\n      .order(\"desc\")\r\n      .paginate(args.paginationOpts);\r\n  },\r\n});\r\n\r\n// Frontend - Infinite scroll automatique\r\nconst { results, status, loadMore } = usePaginatedQuery(\r\n  api.messages.list,\r\n  {},\r\n  { initialNumItems: 20 }\r\n);\r\n```\r\n\r\n**Le trick ?** Combinez avec l'Intersection Observer pour un **infinite scroll parfait** :\r\n\r\n```typescript\r\nuseEffect(() => {\r\n  const observer = new IntersectionObserver(\r\n    ([entry]) => entry.isIntersecting && status === \"CanLoadMore\" && loadMore(20)\r\n  );\r\n  observer.observe(sentinelRef.current);\r\n  return () => observer.disconnect();\r\n}, [status, loadMore]);\r\n```\r\n\r\n## 9. Components : Modules Réutilisables\r\n\r\nConvex permet de créer des **composants backend** packagés comme des modules NPM.\r\n\r\n```typescript\r\n// Installation\r\nnpm install @convex-dev/aggregate\r\n\r\n// Utilisation\r\nimport { Aggregate } from \"@convex-dev/aggregate\";\r\n\r\nconst aggregate = new Aggregate<number>(components.aggregate, {\r\n  sortKey: (doc) => doc.createdAt,\r\n  sumValue: (doc) => doc.amount,\r\n});\r\n\r\n// Obtenir des stats en temps réel\r\nconst stats = await aggregate.sum(ctx, { prefix: [\"sales\", \"2026\"] });\r\n```\r\n\r\n**Components officiels disponibles :**\r\n- `@convex-dev/aggregate` - Agrégations temps réel\r\n- `@convex-dev/auth` - Authentification complète\r\n- `@convex-dev/rate-limiter` - Rate limiting\r\n- `@convex-dev/crons` - Crons avancés\r\n\r\n## 10. Validation avec Zod\r\n\r\nCombinez la puissance de **Zod** avec Convex pour une validation avancée :\r\n\r\n```typescript\r\nimport { zCustomMutation } from \"convex-helpers/server/zod\";\r\nimport { z } from \"zod\";\r\n\r\nconst mutation = zCustomMutation(baseMutation);\r\n\r\nexport const createUser = mutation({\r\n  args: {\r\n    email: z.string().email(),\r\n    age: z.number().min(18).max(120),\r\n    preferences: z.object({\r\n      theme: z.enum([\"light\", \"dark\"]),\r\n      notifications: z.boolean(),\r\n    }),\r\n  },\r\n  handler: async (ctx, args) => {\r\n    // args est parfaitement typé et validé\r\n    return await ctx.db.insert(\"users\", args);\r\n  },\r\n});\r\n```\r\n\r\n**Avantages vs validators natifs :**\r\n- Validations complexes (regex, min/max, enums)\r\n- Messages d'erreur personnalisés\r\n- Transformations de données\r\n- Réutilisation des schémas\r\n\r\n---\r\n\r\n## Récapitulatif\r\n\r\n| Feature | Use Case | Impact |\r\n|---------|----------|--------|\r\n| **Scheduled Functions** | Emails, rappels, jobs différés | ⭐⭐⭐⭐⭐ |\r\n| **Vector Search** | RAG, semantic search | ⭐⭐⭐⭐⭐ |\r\n| **HTTP Actions** | Webhooks, API REST | ⭐⭐⭐⭐ |\r\n| **Optimistic Updates** | UX instantanée | ⭐⭐⭐⭐ |\r\n| **File Storage** | Upload/download | ⭐⭐⭐⭐ |\r\n| **Components** | Code réutilisable | ⭐⭐⭐ |\r\n\r\n---\r\n\r\n**Leçon apprise** : Convex n'est pas juste une \"base de données réactive\". C'est un **backend complet** qui remplace Supabase, Firebase, et même certains services AWS. Creusez la doc, les pépites sont partout.\r\n",
    "html": "<p>Convex, c'est le backend qui a révolutionné ma façon de coder. Mais après des mois à creuser la doc, j'ai découvert des <strong>pépites cachées</strong> que 90% des développeurs n'exploitent pas.</p>\n<p>En tant que Product Engineer, je vais vous révéler les <strong>10 features qui changent tout</strong>.</p>\n<h2>1. Scheduled Functions : Le Cron Killer</h2>\n<p>Oubliez les cron jobs à configurer sur un serveur. Convex permet de <strong>planifier des fonctions directement depuis votre code</strong>.</p>\n<pre><code class=\"language-typescript\">// Planifier une fonction dans 5 minutes\r\nawait ctx.scheduler.runAfter(5 * 60 * 1000, internal.emails.sendReminder, {\r\n  userId: args.userId,\r\n});\r\n\r\n// Planifier à une date précise\r\nawait ctx.scheduler.runAt(new Date(\"2026-02-01T09:00:00Z\"), internal.reports.generate, {\r\n  reportId: args.reportId,\r\n});\n</code></pre>\n<p><strong>La magie ?</strong> Si votre mutation réussit, la fonction est <strong>garantie</strong> de s'exécuter. Si elle échoue, rien n'est planifié. Atomicité parfaite.</p>\n<ul>\n<li>Jusqu'à <strong>1000 fonctions</strong> planifiées simultanément</li>\n<li>Délai de quelques millisecondes à plusieurs années</li>\n<li>Visible dans le dashboard Convex</li>\n</ul>\n<h2>2. Cron Jobs Natifs</h2>\n<p>Pour les tâches récurrentes, Convex a son propre système de crons. Créez un fichier <code>convex/crons.ts</code> :</p>\n<pre><code class=\"language-typescript\">import { cronJobs } from \"convex/server\";\r\nimport { internal } from \"./_generated/api\";\r\n\r\nconst crons = cronJobs();\r\n\r\n// Toutes les heures\r\ncrons.interval(\"sync-data\", { hours: 1 }, internal.sync.pullFromAPI);\r\n\r\n// Chaque jour à 9h UTC\r\ncrons.daily(\"daily-report\", { hourUTC: 9, minuteUTC: 0 }, internal.reports.daily);\r\n\r\n// Syntaxe cron classique\r\ncrons.cron(\"cleanup\", \"0 0 * * 0\", internal.cleanup.weeklyPurge);\r\n\r\nexport default crons;\n</code></pre>\n<p><strong>Avantage vs cron traditionnel</strong> : Pas de serveur à maintenir, logs intégrés, et vos jobs sont <strong>versionnés</strong> avec votre code.</p>\n<h2>3. Vector Search Intégré</h2>\n<p>Pas besoin de Pinecone ou Qdrant pour un MVP. Convex a son propre <strong>moteur de recherche vectorielle</strong>.</p>\n<pre><code class=\"language-typescript\">// schema.ts - Définir l'index vectoriel\r\nexport default defineSchema({\r\n  documents: defineTable({\r\n    content: v.string(),\r\n    embedding: v.array(v.float64()),\r\n  }).vectorIndex(\"by_embedding\", {\r\n    vectorField: \"embedding\",\r\n    dimensions: 1536, // OpenAI embeddings\r\n    filterFields: [\"category\"],\r\n  }),\r\n});\n</code></pre>\n<pre><code class=\"language-typescript\">// Rechercher les documents similaires\r\nconst results = await ctx.vectorSearch(\"documents\", \"by_embedding\", {\r\n  vector: queryEmbedding,\r\n  limit: 10,\r\n  filter: (q) => q.eq(\"category\", \"tech\"),\r\n});\n</code></pre>\n<pre><code class=\"language-mermaid\">flowchart LR\r\n    A[User Query] --> B[Generate Embedding]\r\n    B --> C[Vector Search]\r\n    C --> D[Top K Documents]\r\n    D --> E[LLM Context]\r\n    E --> F[AI Response]\r\n    \r\n    style A fill:#FC5757,color:#fff\r\n    style C fill:#FC5757,color:#fff\r\n    style F fill:#1a1d24,stroke:#FC5757\n</code></pre>\n<p><strong>Le plus ?</strong> La recherche est <strong>immédiatement cohérente</strong>. Contrairement aux bases vectorielles externes, pas de délai de synchronisation.</p>\n<h2>4. File Storage Sans Config</h2>\n<p>Upload, stockage, et serving de fichiers en <strong>3 lignes de code</strong>. Pas de S3 à configurer.</p>\n<pre><code class=\"language-typescript\">// Générer une URL d'upload (valide 1h)\r\nconst uploadUrl = await ctx.storage.generateUploadUrl();\r\n\r\n// Récupérer l'URL publique d'un fichier\r\nconst fileUrl = await ctx.storage.getUrl(storageId);\r\n\r\n// Supprimer un fichier\r\nawait ctx.storage.delete(storageId);\n</code></pre>\n<p><strong>Features cachées :</strong></p>\n<ul>\n<li>Support de <strong>tous les types de fichiers</strong></li>\n<li>URLs signées avec expiration</li>\n<li>Streaming depuis les HTTP Actions</li>\n<li>Métadonnées accessibles</li>\n</ul>\n<h2>5. HTTP Actions : Votre API REST</h2>\n<p>Convex peut exposer des <strong>endpoints HTTP</strong> pour recevoir des webhooks ou créer une API REST.</p>\n<pre><code class=\"language-typescript\">// convex/http.ts\r\nimport { httpRouter } from \"convex/server\";\r\nimport { httpAction } from \"./_generated/server\";\r\n\r\nconst http = httpRouter();\r\n\r\nhttp.route({\r\n  path: \"/webhooks/stripe\",\r\n  method: \"POST\",\r\n  handler: httpAction(async (ctx, request) => {\r\n    const body = await request.json();\r\n    const signature = request.headers.get(\"stripe-signature\");\r\n    \r\n    // Valider et traiter le webhook\r\n    await ctx.runMutation(internal.payments.processWebhook, {\r\n      event: body,\r\n    });\r\n    \r\n    return new Response(\"OK\", { status: 200 });\r\n  }),\r\n});\r\n\r\nexport default http;\n</code></pre>\n<p>Vos endpoints sont accessibles sur <code>https://votre-projet.convex.site/webhooks/stripe</code>.</p>\n<p><strong>Use cases :</strong></p>\n<ul>\n<li>Webhooks (Stripe, GitHub, Discord)</li>\n<li>API publique pour apps tierces</li>\n<li>Intégration avec Zapier/n8n</li>\n</ul>\n<h2>6. Optimistic Updates</h2>\n<p>Rendez votre UI <strong>instantanément réactive</strong> avant même que le serveur réponde.</p>\n<pre><code class=\"language-typescript\">const addTodo = useMutation(api.todos.add).withOptimisticUpdate(\r\n  (localStore, args) => {\r\n    const currentTodos = localStore.getQuery(api.todos.list);\r\n    if (currentTodos !== undefined) {\r\n      localStore.setQuery(api.todos.list, {}, [\r\n        ...currentTodos,\r\n        { _id: \"temp\", text: args.text, completed: false },\r\n      ]);\r\n    }\r\n  }\r\n);\n</code></pre>\n<p><strong>Comment ça marche ?</strong></p>\n<pre><code class=\"language-mermaid\">sequenceDiagram\r\n    participant UI\r\n    participant LocalStore\r\n    participant Convex\r\n    \r\n    UI->>LocalStore: Optimistic Update\r\n    LocalStore->>UI: UI Updated (instant)\r\n    UI->>Convex: Mutation Request\r\n    Convex->>Convex: Process Mutation\r\n    Convex->>LocalStore: Real Data\r\n    LocalStore->>UI: Reconcile (auto)\n</code></pre>\n<p>Si le serveur renvoie des données différentes, Convex <strong>rollback automatiquement</strong> l'update optimiste.</p>\n<h2>7. Internal Functions : L'Encapsulation Parfaite</h2>\n<p>Les <code>internalQuery</code>, <code>internalMutation</code>, et <code>internalAction</code> sont <strong>invisibles</strong> côté client. Parfait pour la logique sensible.</p>\n<pre><code class=\"language-typescript\">// Accessible uniquement depuis le backend\r\nexport const chargeCustomer = internalMutation({\r\n  args: { userId: v.id(\"users\"), amount: v.number() },\r\n  handler: async (ctx, args) => {\r\n    // Logique de facturation sensible\r\n    const user = await ctx.db.get(args.userId);\r\n    await stripe.charges.create({ amount: args.amount, customer: user.stripeId });\r\n    await ctx.db.patch(args.userId, { lastCharged: Date.now() });\r\n  },\r\n});\r\n\r\n// Appel depuis une autre fonction\r\nawait ctx.runMutation(internal.billing.chargeCustomer, { userId, amount: 1999 });\n</code></pre>\n<p><strong>Sécurité</strong> : Ces fonctions n'apparaissent pas dans l'objet <code>api</code> exposé au client. Impossible de les appeler depuis le frontend.</p>\n<h2>8. Pagination Réactive</h2>\n<p>La pagination Convex est <strong>fully reactive</strong>. Quand un document change, votre page se met à jour automatiquement.</p>\n<pre><code class=\"language-typescript\">// Backend\r\nexport const listMessages = query({\r\n  args: { paginationOpts: paginationOptsValidator },\r\n  handler: async (ctx, args) => {\r\n    return await ctx.db\r\n      .query(\"messages\")\r\n      .order(\"desc\")\r\n      .paginate(args.paginationOpts);\r\n  },\r\n});\r\n\r\n// Frontend - Infinite scroll automatique\r\nconst { results, status, loadMore } = usePaginatedQuery(\r\n  api.messages.list,\r\n  {},\r\n  { initialNumItems: 20 }\r\n);\n</code></pre>\n<p><strong>Le trick ?</strong> Combinez avec l'Intersection Observer pour un <strong>infinite scroll parfait</strong> :</p>\n<pre><code class=\"language-typescript\">useEffect(() => {\r\n  const observer = new IntersectionObserver(\r\n    ([entry]) => entry.isIntersecting &#x26;&#x26; status === \"CanLoadMore\" &#x26;&#x26; loadMore(20)\r\n  );\r\n  observer.observe(sentinelRef.current);\r\n  return () => observer.disconnect();\r\n}, [status, loadMore]);\n</code></pre>\n<h2>9. Components : Modules Réutilisables</h2>\n<p>Convex permet de créer des <strong>composants backend</strong> packagés comme des modules NPM.</p>\n<pre><code class=\"language-typescript\">// Installation\r\nnpm install @convex-dev/aggregate\r\n\r\n// Utilisation\r\nimport { Aggregate } from \"@convex-dev/aggregate\";\r\n\r\nconst aggregate = new Aggregate&#x3C;number>(components.aggregate, {\r\n  sortKey: (doc) => doc.createdAt,\r\n  sumValue: (doc) => doc.amount,\r\n});\r\n\r\n// Obtenir des stats en temps réel\r\nconst stats = await aggregate.sum(ctx, { prefix: [\"sales\", \"2026\"] });\n</code></pre>\n<p><strong>Components officiels disponibles :</strong></p>\n<ul>\n<li><code>@convex-dev/aggregate</code> - Agrégations temps réel</li>\n<li><code>@convex-dev/auth</code> - Authentification complète</li>\n<li><code>@convex-dev/rate-limiter</code> - Rate limiting</li>\n<li><code>@convex-dev/crons</code> - Crons avancés</li>\n</ul>\n<h2>10. Validation avec Zod</h2>\n<p>Combinez la puissance de <strong>Zod</strong> avec Convex pour une validation avancée :</p>\n<pre><code class=\"language-typescript\">import { zCustomMutation } from \"convex-helpers/server/zod\";\r\nimport { z } from \"zod\";\r\n\r\nconst mutation = zCustomMutation(baseMutation);\r\n\r\nexport const createUser = mutation({\r\n  args: {\r\n    email: z.string().email(),\r\n    age: z.number().min(18).max(120),\r\n    preferences: z.object({\r\n      theme: z.enum([\"light\", \"dark\"]),\r\n      notifications: z.boolean(),\r\n    }),\r\n  },\r\n  handler: async (ctx, args) => {\r\n    // args est parfaitement typé et validé\r\n    return await ctx.db.insert(\"users\", args);\r\n  },\r\n});\n</code></pre>\n<p><strong>Avantages vs validators natifs :</strong></p>\n<ul>\n<li>Validations complexes (regex, min/max, enums)</li>\n<li>Messages d'erreur personnalisés</li>\n<li>Transformations de données</li>\n<li>Réutilisation des schémas</li>\n</ul>\n<hr>\n<h2>Récapitulatif</h2>\n<p>| Feature | Use Case | Impact |\r\n|---------|----------|--------|\r\n| <strong>Scheduled Functions</strong> | Emails, rappels, jobs différés | ⭐⭐⭐⭐⭐ |\r\n| <strong>Vector Search</strong> | RAG, semantic search | ⭐⭐⭐⭐⭐ |\r\n| <strong>HTTP Actions</strong> | Webhooks, API REST | ⭐⭐⭐⭐ |\r\n| <strong>Optimistic Updates</strong> | UX instantanée | ⭐⭐⭐⭐ |\r\n| <strong>File Storage</strong> | Upload/download | ⭐⭐⭐⭐ |\r\n| <strong>Components</strong> | Code réutilisable | ⭐⭐⭐ |</p>\n<hr>\n<p><strong>Leçon apprise</strong> : Convex n'est pas juste une \"base de données réactive\". C'est un <strong>backend complet</strong> qui remplace Supabase, Firebase, et même certains services AWS. Creusez la doc, les pépites sont partout.</p>"
  },
  "_id": "posts/convex-fonctionnalites-cachees-2026.md",
  "_raw": {
    "sourceFilePath": "posts/convex-fonctionnalites-cachees-2026.md",
    "sourceFileName": "convex-fonctionnalites-cachees-2026.md",
    "sourceFileDir": "posts",
    "contentType": "markdown",
    "flattenedPath": "posts/convex-fonctionnalites-cachees-2026"
  },
  "type": "Post",
  "url": "/blog/convex-fonctionnalites-cachees-2026",
  "slug": "convex-fonctionnalites-cachees-2026"
}